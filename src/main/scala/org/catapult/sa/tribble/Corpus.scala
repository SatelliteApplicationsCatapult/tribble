package org.catapult.sa.tribble

import java.io.{File, FileInputStream, FileOutputStream, PrintStream}
import java.nio.charset.StandardCharsets
import java.nio.file.{Files, Paths}
import java.security.MessageDigest
import javax.xml.bind.DatatypeConverter

import org.apache.commons.io.IOUtils

import scala.collection.mutable
import scala.util.Random

/**
  * Functions for dealing with the corpus of inputs and mutating them.
  */
object Corpus {

  val CORPUS = "corpus"
  val FAILED = "failed"

  def validateDirectories(arguments : Map[String, String]) : Boolean = {
    val corpusFile = new File(arguments(Corpus.CORPUS))
    if (corpusFile.exists() && (! corpusFile.isDirectory || !corpusFile.canWrite)) {
      println("ERROR: corpus path exists but is not a directory: " + corpusFile.getAbsolutePath)
      return false
    }

    if (!corpusFile.exists()) {
      println("Corpus folder does not exist. Creating. WARNING you should give the tribbles some guidance where to start.")
      Files.createDirectory(Paths.get(arguments(Corpus.CORPUS)))
    }

    val failedFile = new File(arguments(Corpus.FAILED))
    if (failedFile.exists() && (! failedFile.isDirectory || !failedFile.canWrite)) {
      println("ERROR: failed path exists but is not a directory: " + failedFile.getAbsolutePath)
      return false
    }

    if (! failedFile.exists()) {
      println("Failed directory does not exist. Creating.")
      Files.createDirectory(Paths.get(arguments(Corpus.FAILED)))
    }

    true
  }

  def readCorpusInputStack(arguments: Map[String, String], stack : mutable.ArrayStack[Array[Byte]]) : Unit = {
    Files.newDirectoryStream(Paths.get(arguments(CORPUS))).forEach { f =>
      if (f.getFileName.endsWith(".hex")) {
        val hexString = IOUtils.toString(new FileInputStream(f.toFile), StandardCharsets.UTF_8)
        stack.push(DatatypeConverter.parseHexBinary(hexString))
      } else {
        stack.push(IOUtils.toByteArray(new FileInputStream(f.toFile)))
      }
    }
  }

  def saveResult(input : Array[Byte], success : Boolean, ex : Option[Throwable], arguments : Map[String, String]) : Unit = {
    val md5 = MessageDigest.getInstance("MD5")
    val filename = DatatypeConverter.printHexBinary(md5.digest(input))

    if (!success) { // failed, record it in the crashers. But don't keep it for mutations.
      Corpus.saveArray(input, s"${arguments(FAILED)}/$filename.failed")
      ex.foreach(e => {
        val exOut = new PrintStream(new FileOutputStream(s"${arguments(FAILED)}/$filename.stacktrace"))
        e.printStackTrace(exOut)
        exOut.flush()
        exOut.close()
      })
    } else { // new and didn't fail so add it to our corpus
      Corpus.saveArray(input, s"${arguments(CORPUS)}/$filename.input")

    }
  }

  def saveArray(input : Array[Byte], fileName : String) : Unit = {
    if (containsUnprintableChars(input)) {
      if (! new File(s"$fileName.hex").exists()) {
        IOUtils.write(DatatypeConverter.printHexBinary(input), new FileOutputStream(s"$fileName.hex"), StandardCharsets.UTF_8)
      }
    } else {
      if (! new File(fileName).exists()) {
        IOUtils.write(input, new FileOutputStream(fileName))
      }
    }
  }

  // TODO: this should handle other unprintable characters. (Really we should deal with multibyte stuff and so on)
  // Though on the other hand we can probably deal with other lower order characters easily
  // We should probably keep non hex files to actually type-able stuff
  private def containsUnprintableChars(input : Array[Byte]) : Boolean = input.exists(b => b < 0x20 || b > 0x7F)

  def mutate(input : Array[Byte], rand : Random) : Array[Byte] = {
    // TODO: an empty array is valid
    if (input.isEmpty) {
      Array[Byte](0x00) // if we started with empty input make a single byte we can mutate more next time.
    } else { // todo : Many more mutation ideas
      rand.nextInt(100) match { // Make extending the array much less likely than changing existing values
        case 0 => extendArray(input, rand)
        case 1 => doubleUpArray(input, rand)
        case 2 => extendArray(input, rand, 100) // big extend
        case _ => mutateInPlace(input, rand)
      }
    }
  }

  private def mutateInPlace(input : Array[Byte], rand : Random) : Array[Byte] = {
    rand.nextInt(4) match {
      case 0 => // add one to a random byte
        val index = rand.nextInt(input.length)
        input.update(index, (input(index) + 1).asInstanceOf[Byte])
        input
      case 1 => // Swap a random byte with another randomly generated byte
        changeOneByte(input, rand)
      case 2 => // Bitshift right random byte
        val index = rand.nextInt(input.length)
        input.update(index, (input(index) >> 1).asInstanceOf[Byte])
        input
      case 3 => // Bitshift left random byte
        val index = rand.nextInt(input.length)
        input.update(index, (input(index) << 1).asInstanceOf[Byte])
        input
      case _ => // default change a byte at random
        println("Unknown mutation option.")
        changeOneByte(input, rand)
    }
  }

  private def changeOneByte(input : Array[Byte], rand : Random) : Array[Byte] = {
    val index = rand.nextInt(input.length)
    val value = rand.nextInt(255).asInstanceOf[Byte]
    input.update(index, value)
    input
  }


  private def extendArray(input : Array[Byte], rand : Random, length : Int = 10) : Array[Byte] = {
    val extra = new Array[Byte](rand.nextInt(length))
    rand.nextBytes(extra)
    val result = new Array[Byte](input.length + extra.length)
    input.copyToArray(result, 0)
    extra.copyToArray(extra, input.length)
    result
  }

  private def doubleUpArray(input : Array[Byte], rand : Random) : Array[Byte] = {
    val result = new Array[Byte](input.length * 2)
    input.copyToArray(result, 0)
    input.copyToArray(result, input.length)
    result
  }

}
