package org.catapult.sa.tribble

import javax.xml.bind.DatatypeConverter

import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider
import org.springframework.core.`type`.filter.AssignableTypeFilter

import scala.collection.mutable
import scala.util.Random
/**
 * Hello world! with calculated coverage
 *
 */
object App {

  def main(args : Array[String]) : Unit = {

    // TODO: Argument parsing.
    // TODO: Argument for corpus directory.
    // TODO: Allow class name to be an argument.


    val scanner = new ClassPathScanningCandidateComponentProvider(true)
    scanner.addIncludeFilter(new AssignableTypeFilter(classOf[FuzzTest]))

    // TODO: Add argument parsing for search class path
    scanner.findCandidateComponents("org.catapult.sa").forEach(bd => {

      println(bd.getBeanClassName)

      val targetName = bd.getBeanClassName

      fuzzLoop(targetName)
    })
  }

  private lazy val rand = new Random()

  private def fuzzLoop(targetName : String): Unit = {
    val coverageSet = new mutable.HashSet[String]()


    // TODO: Threads
    // TODO: Saving corpus
    // TODO: Stats counting and logging.

    val workStack = new mutable.ArrayStack[Array[Byte]]()
    workStack.push(Array[Byte]())
    // TODO: Implement initial corpus run

    def loop() {

      val old = if (workStack.isEmpty) { // stack expired so do random stuff
        // TODO: Go back to the saved corpus here? and refill the stack?  
        val result = new Array[Byte](rand.nextInt(9) + 1) // we will already have done the empty list at the start
        rand.nextBytes(result)
        result
      } else {
        workStack.pop()
      }

      val newInput = mutate(old)
      println("input: " + DatatypeConverter.printHexBinary(newInput))
      val (result, hash) = runOnce(targetName, newInput)
      if (!coverageSet.contains(hash)) {
        coverageSet.add(hash)
        // TODO: Saving updated corpus
        workStack.push(newInput)
        if (!result) { // failed
          // TODO: Save the failed ones some where.
        }
      }

      loop()
    }
    loop()
  }

  private def mutate(input : Array[Byte]) : Array[Byte] = {
    // TODO: Pull this out into a better place
    // TODO: an empty array is valid
    if (input.isEmpty) {
      Array[Byte](0x00) // if we started with empty input make a single byte we can mutate more next time.
    } else { // todo : Many more mutation ideas
      rand.nextInt(4) match {
        case 0 =>
          val extra = new Array[Byte](rand.nextInt(10))
          rand.nextBytes(extra)
          val result = new Array[Byte](input.length + extra.length)
          input.copyToArray(result, 0)
          extra.copyToArray(extra, input.length)
          result
        case 1 => // TODO: add one to a random byte
          val index = rand.nextInt(input.length)
          input.update(index, (input(index) + 1).asInstanceOf[Byte])
          input
        case 2 => // TODO: double up the existing buffer
          val result = new Array[Byte](input.length * 2)
          input.copyToArray(result, 0)
          input.copyToArray(result, input.length)
          result
        case 3 => // TODO: Swap a random byte with another randomly generated byte
          val index = rand.nextInt(input.length)
          val value = rand.nextInt(255).asInstanceOf[Byte]
          input.update(index, value)
          input
        case _ =>
          println("Unknown mutation option.")
          val index = rand.nextInt(input.length)
          val value = rand.nextInt(255).asInstanceOf[Byte]
          input.update(index, value)
          input
      }


    }
  }

  private def runOnce(targetName : String, input : Array[Byte]) : (Boolean, String) = {

    val memoryClassLoader = new CoverageMemoryClassLoader()
    memoryClassLoader.addClass(targetName)

    val targetClass = memoryClassLoader.loadClass(targetName)

    var result = true

    // Here we execute our test target class through its interface
    val targetInstance = targetClass.newInstance.asInstanceOf[FuzzTest]
    try {
      result = targetInstance.test(input)
    } catch {
      case e : Throwable =>
        printf("error thrown from test environment ")
        e.printStackTrace()
        result = false
    }

    (result, memoryClassLoader.generateCoverageHash())
  }


}

