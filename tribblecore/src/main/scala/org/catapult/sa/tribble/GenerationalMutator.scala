package org.catapult.sa.tribble

import scala.util.Random
import org.catapult.sa.tribble.Mutator._

/**
  * outer layer of mutator system
  *
  * Adjusts probabilities of individual mutations as it goes based on if the results are interesting.
  */
class GenerationalMutator() {

  private var mutators : List[Mutator] = List()

  def mutate(input : Array[Byte], r : Random) : History = {

    if (input.length > mutators.length) {
      mutators = mutators.padTo(input.length, new Mutator())
    }

    val i = r.nextInt(input.length)
    mutators(i).mutate(input, i, r)

  }

  def learn(history : MutatorIndex, interesting : Boolean) : Unit = {
    mutators(history.m).learn(history, interesting)
  }

  def toTSV : String = mutators.map(_.toTSV).mkString("\n")

}

object GenerationalMutator {
  def fromTSV(in : String) : GenerationalMutator = {
    val result = new GenerationalMutator()
    result.mutators = in.split("\n").map(Mutator.fromTSV).toList
    result
  }
}


class Mutator() {

  private var probability : List[Int] = List().padTo(8, 50)

  private val lock = new Object()

  def mutate(input : Array[Byte], index : Int, r : Random) : History = {

    val choice = pick(r)

    // TODO: More mutations.
    // TODO: Splice in more bytes
    // TODO: remove byte
    val newData = choice match {
      case 0 => // Add one to a random byte
        input.update(index, b(input(index) + 1))
        input
      case 1 => // Swap a random byte with another randomly generated byte
        input.update(index, b(r.nextInt(255)))
        input
      case 2 => // Bit shift right random byte
        input.update(index, b(input(index) >> 1))
        input
      case 3 => // Bit shift left random byte
        input.update(index, b(input(index) << 1))
        input
      case 4 => // Minus one to a random byte
        input.update(index, b(input(index) - 1))
        input
      case 5 => // Replace bytes with random entry from list of known interesting values
        val entry = interestingBytes(r.nextInt(interestingBytes.length))
        input.update(index, entry)
        input
      case 6 => // Flip all the bits in a byte.
        input.update(index, b(input(index) ^ 0xFF))
        input
      case 7 => // Add an extra byte after
        val result = new Array[Byte](input.length + 1)
        Array.copy(input, 0, result, 0, index)
        result.update(index, b(r.nextInt(255)))
        Array.copy(input, index, result, index+1, result.length - 1 - index)
        result
    }


    History(newData, MutatorIndex(index, choice))
  }

  def learn(index : MutatorIndex, interesting : Boolean) : Unit = {
    lock.synchronized {
      if (interesting) {
        if (probability(index.p) < 100) {
          probability = probability.updated(index.p, probability(index.p) + 1)
        }
      } else {
        if (probability(index.p) > 0) {
          probability = probability.updated(index.p, probability(index.p) - 1)
        }
      }
    }
  }

  def toTSV : String = probability.mkString("\t")

  private def pick(r : Random): Int = {
    lock.synchronized {
      val range = probability.sum

      val value = r.nextInt(range)
      var counter = 0
      var index = 0
      // TODO: is there a better way to do this? Faster? histogram bin picking functionally.
      while (value > counter && index < probability.length) {
        counter = counter + probability(index)
        index = index + 1
      }

      index
    }
  }
}

object Mutator {
  def fromTSV(in : String) : Mutator = {
    val result = new Mutator
    result.probability = in.split("\t").map(_.toInt).toList

    result
  }

  lazy val interestingBytes = List[Byte](
    b(0x00),
    b(0xFF),
    b(0xF0),
    b(0x0F),
    b(0x01),
    b(0x10),
    b(0xCC),
    b('a'),
    b('z'),
    b('A'),
    b('Z'),
    b('0'),
    b('9'),
    b('\n'),
    b('\r'),
    b('\t')
  )

  def b(i: Int): Byte = i.asInstanceOf[Byte]
}


case class History(result : Array[Byte], index : MutatorIndex)
case class MutatorIndex(m : Int, p : Int)
