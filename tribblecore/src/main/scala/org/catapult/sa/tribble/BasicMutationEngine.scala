package org.catapult.sa.tribble

import scala.util.Random

import org.catapult.sa.tribble.BasicMutationEngine._

/**
  * Basic mutation engine. Simply randomly picks a mutation for a defined set of possible options.
  */
class BasicMutationEngine(rand: Random) extends MutationEngine {

  def mutate(input: Array[Byte]): Array[Byte] = {
    // TODO: an empty array is valid
    if (input == null || input.isEmpty) {
      Array[Byte](0x00) // if we started with empty input make a single byte we can mutate more next time.
    } else { // todo : Many more mutation ideas
      rand.nextInt(100) match { // Make extending the array much less likely than changing existing values
        case 0 => extendArray(input, rand)
        case 1 => Array.concat(input, input)
        case 2 => extendArray(input, rand, 100) // big extend
        case 3 => if (input.length > 4) {
          trim(input, rand)
        } else {
          mutate(input) // try again.
        }
        case 4 =>
          val newPrefix = byteMarkers(rand.nextInt(byteMarkers.length))
          Array.concat(newPrefix, input)
        case _ => mutateInPlace(input)
      }
    }
  }

  private def mutateInPlace(input: Array[Byte]): Array[Byte] = {
    val index = rand.nextInt(input.length)
    rand.nextInt(10) match {
      case 0 => // Add one to a random byte
        input.update(index, b(input(index) + 1))
        input
      case 1 => // Swap a random byte with another randomly generated byte
        changeOneByte(input, rand)
      case 2 => // Bit shift right random byte
        input.update(index, b(input(index) >> 1))
        input
      case 3 => // Bit shift left random byte
        input.update(index, b(input(index) << 1))
        input
      case 4 => // Minus one to a random byte
        input.update(index, b(input(index) - 1))
        input
      case 5 => // Shuffle two random bytes
        val index2 = rand.nextInt(input.length)
        if (index != index2) {
          val v1 = input(index)
          input.update(index, input(index2))
          input.update(index2, v1)
          input
        } else {
          // Unlikely unless very short array. Recurse and try again. Random numbers it will exit at some point unless
          // the rng is really broken. (yes this is not in position 4 in case of the use of the XKCD rng.)
          mutateInPlace(input)
        }
      case 6 => // Replace bytes with random entry from list of known interesting values
        val entry = interestingBytes(rand.nextInt(interestingBytes.length))
        input.update(index, entry)
        input
      case 7 => // Replace a block of bytes with an interesting set of bytes.
        if (index + 3 < input.length) {
          val entry = interestingInts(rand.nextInt(interestingInts.length))
          input.update(index, b((entry & 0xFF000000) >> 24))
          input.update(index + 1, b((entry & 0xFF0000) >> 16))
          input.update(index + 2, b((entry & 0xFF00) >> 8))
          input.update(index + 3, b(entry & 0xFF))

          input
        } else { // Too close to the end so try something else.
          mutateInPlace(input) // try again.
        }
      case 8 => // Flip all the bits in a byte.
        input.update(index, b(input(index) ^ 0xFF))
        input
      case 9 => // Flip all the bits in a four byte block
        if (index + 3 < input.length) {
          input.update(index, b(input(index) ^ 0xFF))
          input.update(index+1, b(input(index+1) ^ 0xFF))
          input.update(index+2, b(input(index+2) ^ 0xFF))
          input.update(index+3, b(input(index+3) ^ 0xFF))
          input
        } else { // Too close to the end so try something else.
          mutateInPlace(input) // try again.
        }
      case 10 => // replace the first byte with a random number.
        input.update(0, b(index))
        input
      case _ => // default change a byte at random
        println("Unknown mutation option.")
        changeOneByte(input, rand)
    }
  }

}

object BasicMutationEngine {

  def trim(input: Array[Byte], rand: Random): Array[Byte] = {
    val shortenBy = rand.nextInt(input.length / 2) // don't chop more than half the array off.
    val result = new Array[Byte](input.length - shortenBy)
    Array.copy(input, 0, result, 0, input.length - shortenBy)
    result
  }

  def changeOneByte(input: Array[Byte], rand: Random): Array[Byte] = {
    val index = rand.nextInt(input.length)
    val value = b(rand.nextInt(255))
    input.update(index, value)
    input
  }


  def extendArray(input: Array[Byte], rand: Random, length: Int = 10): Array[Byte] = {
    val extra = new Array[Byte](rand.nextInt(length))
    rand.nextBytes(extra)
    Array.concat(input, extra)
  }

  val interestingBytes : List[Byte] = List[Byte](
    b(0x00),
    b(0xFF),
    b(0xF0),
    b(0x0F),
    b(0x01),
    b(0x10),
    b(0xCC),
    b('a'),
    b('z'),
    b('A'),
    b('Z'),
    b('0'),
    b('9'),
    b('('),
    b(')'),
    b('<'),
    b('>'),
    b('{'),
    b('}'),
    b('['),
    b(']'),
    b(';'),
    b(' '),
    b('-'),
    b('!'),
    b('\r'),
    b('\n'),
    b('\t'),
    b(','),
    b('*'),
    b('\''),
    b('"'),
    b('\\')
  )

  val interestingInts : List[Int] = List[Int](
    Int.MaxValue,
    0,
    Int.MinValue,
    Int.MaxValue - 1,
    Int.MinValue + 1,
    -1,
    1,
    16,
    32,
    64,
    128,
    256,
    512,
    1024,
    2048
  )

  val byteMarkers : List[Array[Byte]] = List[Array[Byte]] (
    Array(b(0x00), b(0x00), b(0x00), b(0x0C), b(0x6A), b(0x50), b(0x20), b(0x20), b(0x0D), b(0x0A)), // jpeg2000
    Array(b(0x00), b(0x00), b(0x00), b(0x18), b(0x66), b(0x74), b(0x79), b(0x70), b(0x33), b(0x67), b(0x70), b(0x35)), // MOV
    Array(b(0x00), b(0x00), b(0x01)), // ICO (Not including the half byte B)
    Array(b(0x00), b(0x01), b(0x00), b(0x00), b(0x00)), // True Type font.
    Array(b(0x01), b(0xFF), b(0x02), b(0x04), b(0x03), b(0x02))  // DRW
    // TODO: add many many more of these.
  )

  // Short cut to convert to byte.
  def b(i: Int): Byte = i.asInstanceOf[Byte]
}